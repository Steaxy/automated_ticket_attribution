name: deploy-dev

on:
  push:
    tags:
      - "*-dev"

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Ensure tag commit is on dev branch
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin dev --prune
          TAG_COMMIT="$(git rev-parse HEAD)"
          git merge-base --is-ancestor "${TAG_COMMIT}" "origin/dev"

      - uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          cache: "pip"

      - name: Quality gates
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt
          make lint
          make type-check
          make test

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Build & push Docker image to ECR
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          AWS_REGION="${{ vars.AWS_REGION }}"

          AWS_ACCOUNT_ID="${{ vars.AWS_ACCOUNT_ID }}"
          ECR_REPO="${{ vars.ECR_REPO }}"
          : "${AWS_ACCOUNT_ID:?Missing vars.AWS_ACCOUNT_ID}"
          : "${ECR_REPO:?Missing vars.ECR_REPO}"

          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPO}:${TAG}"

          aws ecr get-login-password --region "${AWS_REGION}" \
            | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

          docker build -t "${IMAGE_URI}" .
          docker push "${IMAGE_URI}"

          echo "IMAGE_URI=${IMAGE_URI}" >> "$GITHUB_ENV"

      - name: Package source (deploy bundle)
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          OUT="/tmp/atta-${TAG}.tar.gz"

          tar \
            --exclude='./.git' \
            --exclude='./.venv' \
            --exclude='./venv' \
            --exclude='./output' \
            --exclude='./__pycache__' \
            --exclude='./.pytest_cache' \
            --exclude='./.mypy_cache' \
            --exclude='./.ruff_cache' \
            -czf "${OUT}" .

          mv "${OUT}" "atta-${TAG}.tar.gz"

      - name: Upload artifact to S3
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          BUCKET="${{ vars.DEPLOY_BUCKET }}"
          : "${BUCKET:?Missing vars.DEPLOY_BUCKET}"
          aws s3 cp "atta-${TAG}.tar.gz" "s3://${BUCKET}/atta/${TAG}/atta-${TAG}.tar.gz"

      - name: Deploy on EC2 via SSM Run Command (download bundle + run deploy + wait)
        shell: bash
        run: |
          set -euo pipefail

          TAG="${GITHUB_REF_NAME}"
          INSTANCE_ID="${{ vars.DEV_EC2_INSTANCE_ID }}"
          AWS_REGION="${{ vars.AWS_REGION }}"
          ATTA_IMAGE="${IMAGE_URI}"
          BUCKET="${{ vars.DEPLOY_BUCKET }}"
          # NEW: optional, set in repo variables if you want; otherwise default is /atta/dev
          SSM_PATH="${{ vars.SSM_PATH }}"
          if [[ -z "${SSM_PATH}" ]]; then
            SSM_PATH="/atta/dev"
          fi

          : "${INSTANCE_ID:?Missing vars.DEV_EC2_INSTANCE_ID}"
          : "${AWS_REGION:?Missing vars.AWS_REGION}"
          : "${ATTA_IMAGE:?Missing IMAGE_URI env (Build step failed?) }"
          : "${BUCKET:?Missing vars.DEPLOY_BUCKET}"

          export TAG AWS_REGION ATTA_IMAGE BUCKET SSM_PATH

          # NEW: build JSON safely (no escaping hell)
          PARAMS_JSON="$(python - <<'PY'
          import json, os
          tag = os.environ["TAG"]
          aws_region = os.environ["AWS_REGION"]
          atta_image = os.environ["ATTA_IMAGE"]
          bucket = os.environ["BUCKET"]
          ssm_path = os.environ["SSM_PATH"]

          s3_uri = f"s3://{bucket}/atta/{tag}/atta-{tag}.tar.gz"

          commands = [
              "set -euo pipefail",
              f"export TAG='{tag}'",
              f"export AWS_REGION='{aws_region}'",
              f"export AWS_DEFAULT_REGION='{aws_region}'",
              f"export ATTA_IMAGE='{atta_image}'",
              f"export SSM_PATH='{ssm_path}'",
              "echo '[SSM] whoami='$(whoami)",
              "echo '[SSM] TAG='${TAG}",
              "echo '[SSM] ATTA_IMAGE='${ATTA_IMAGE}",
              "echo '[SSM] SSM_PATH='${SSM_PATH}",
              f"echo '[SSM] Download bundle: {s3_uri}'",

              # Work dir on instance
              "WORK_DIR=\"/tmp/atta-deploy-${TAG}-$RANDOM\"",
              "mkdir -p \"$WORK_DIR\"",
              "cd \"$WORK_DIR\"",

              # Download + extract bundle
              f"aws s3 cp '{s3_uri}' bundle.tar.gz",
              "tar -xzf bundle.tar.gz",

              # Run deploy script from bundle
              "chmod +x deploy/ec2_deploy.sh",
              "./deploy/ec2_deploy.sh",
          ]

          print(json.dumps({"commands": commands}))
          PY
          )"

          COMMAND_ID="$(
            aws ssm send-command \
              --instance-ids "${INSTANCE_ID}" \
              --document-name "AWS-RunShellScript" \
              --comment "Deploy ATTA ${TAG}" \
              --parameters "${PARAMS_JSON}" \
              --query "Command.CommandId" \
              --output text
          )"

          echo "SSM CommandId=${COMMAND_ID}"

          # wait for completion, then print logs and fail if not Success
          aws ssm wait command-executed --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}"

          STATUS="$(
            aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query "Status" \
              --output text
          )"

          echo "----- SSM STATUS -----"
          echo "${STATUS}"

          echo "----- SSM STDOUT -----"
          aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardOutputContent" \
            --output text

          echo "----- SSM STDERR -----"
          aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "StandardErrorContent" \
            --output text

          if [[ "${STATUS}" != "Success" ]]; then
            echo "SSM command failed with status: ${STATUS}" >&2
            exit 1
          fi